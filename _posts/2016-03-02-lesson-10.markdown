---
layout: post
title:  "Lesson 10"
number: 10
date:   2016-03-02 14:32:11 +0200
categories: csharp
comments: false
permalink: /lesson-10
excerpt_separator: <!--more-->
---
Today we are going to speak about exception handling, operator overloading and Extension Methods.
<!--more-->

# Agenda #
* <a href="#exception-handling">Exception handling</a>
* <a href="#operator-overloading">Operator overloading</a>
* <a href="#extension-methods">Extension Methods</a>
* <a href="#references">References</a>
* <a href="#presentation">Presentation</a>

# <a name="exception-handling">Exception handling</a> #
The C# language's exception handling features help you deal with any unexpected or exceptional situations that occur when a program is running. Exception handling uses the try, catch, and finally keywords to try actions that may not succeed, to handle failures when you decide that it is reasonable to do so, and to clean up resources afterward. Exceptions can be generated by the common language runtime (CLR), by the .NET Framework or any third-party libraries, or by application code. Exceptions are created by using the throw keyword.

How try-catch operator looks:
{% highlight csharp %}
try
{
    //ToDo: your code goes here
}
catch
{
    //ToDo: if something goes wrong,
    //ToDo: this block of code will be executed
}
{% endhighlight %}

try-catch operator in action demo:
{% highlight csharp %}
while (true)
{
    Console.WriteLine("Calculation started.");
    try
    {
        Console.Write("Enter a: ");
        int a = int.Parse(Console.ReadLine());
        Console.Write("Enter b: ");
        int b = int.Parse(Console.ReadLine());
        Console.WriteLine($"{a}/{b} = {a/b}");
    }
    catch
    {
        Console.WriteLine("Operation failed.");
    }

    Console.WriteLine("Would you like continue calculations? y/n");
    if (Console.ReadLine().ToLower() != "y")
    {
        break;
    }
}
Console.WriteLine("Good bye!");
{% endhighlight %}

try-catch-finally operator in action demo:
{% highlight csharp %}
while (true)
{
    Console.WriteLine("Calculation started.");
    try
    {
        Console.Write("Enter a: ");
        int a = int.Parse(Console.ReadLine());
        Console.Write("Enter b: ");
        int b = int.Parse(Console.ReadLine());
        Console.WriteLine($"{a}/{b} = {a/b}");
    }
    catch (Exception e)
    {
        Console.WriteLine("Operation failed. Message: {0}", e);
    }
    finally
    {
        Console.WriteLine("Current calculation completed.");
    }

    Console.WriteLine("Would you like continue calculations? y/n");
    if (Console.ReadLine().ToLower() != "y")
    {
        break;
    }
}
{% endhighlight %}
try..finally will run your cleanup code and then the exception will keep going, to be handled by something that knows what to do with it.
finally block will be always executed despite exception occured or not.

Let's create a custom exception class. In order to create an exception handling class, it has to be inherited from System.Exception type, like shown on demo below:
{% highlight csharp %}
class AttendanceException : Exception
{
    public AttendanceException()
    {
    }

    public AttendanceException(string message) : base(message)
    {
    }

    public AttendanceException(string message, Exception innerException) : base(message, innerException)
    {
    }

    protected AttendanceException(SerializationInfo info, StreamingContext context) : base(info, context)
    {
    }
}
{% endhighlight %}

Application that uses this class can be similar to:
{% highlight csharp %}
int pupilsNumber = 0;
try
{
    pupilsNumber = int.Parse(Console.ReadLine());

    if (pupilsNumber == 0)
    {
        throw new AttendanceException("Everybody absent");
    }
}
catch (AttendanceException)
{
    Console.WriteLine("Lesson is ignored :(");
}
catch (Exception e)
{
    Console.WriteLine(e);
}

Console.WriteLine($"{pupilsNumber} pupils here");
{% endhighlight %}
Please pay your attention to throw operator.
The throw statement is used to signal the occurrence of an anomalous situation (exception) during the program execution.

# <a name="operator-overloading">Operator overloading</a> #
C# allows user-defined types to overload operators by defining static member functions using the operator keyword. Not all operators can be overloaded, however, and others have restrictions, as listed by this <a href="https://msdn.microsoft.com/en-us/library/8edha89s.aspx">link</a>

Example of overloaded operator:
{% highlight csharp %}
class Material
{
    public int Weight { get; set; }
    public string Name { get; set; }

    public static Material operator + (Material m1, Material m2)
    {
        return new Material
        {
            Name = m1.Name+" and "+ m2.Name,
            Weight = m1.Weight + m2.Weight
        };
    }
}
{% endhighlight %}

And its usage:

{% highlight csharp %}
Material water = new Material
{
    Name = "Water",
    Weight = 120
};

Material salt = new Material
{
    Name = "Salt",
    Weight = 15
};

Material solterWater = water + salt;

Console.WriteLine($"{solterWater.Name}, {solterWater.Weight}");
{% endhighlight %}

# <a name="extension-methods">Extension Methods</a> #
Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.
Example below demonstrates how to add additional functionality for int type.
{% highlight csharp %}
public static class IntExtensions
{
    public static int Increment(this int n, int amount)
    {
        return n + amount;
    }
}

class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine(10.Increment(3));
        Console.ReadLine();
    }
}
{% endhighlight %}

# <a name="references">References</a> #

* [Exception Handling] [exception-handling-1]
* [Exceptions and Exception Handling] [exception-handling-2]
* [Throw keyword] [throw]
* [Creating Custom Exceptions in .NET] [creating-custom-exceptions-in-dotnet]
* [Overloadable Operators] [overloadable-operators]
* [Extension Methods] [extension-methods]

# <a name="presentation">Presentation</a> #
<iframe src="//www.slideshare.net/slideshow/embed_code/key/FKHIGpp0jj72jO" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/ohoncharuk/lesson10-62141347" title="Lesson 10" target="_blank">Lesson 10</a> </strong> from <strong><a href="//www.slideshare.net/ohoncharuk" target="_blank">Alex Honcharuk</a></strong> </div>

[exception-handling-1]: https://msdn.microsoft.com/en-us/library/ms173162.aspx
[exception-handling-2]: https://msdn.microsoft.com/en-us/library/ms173160.aspx
[throw]: https://msdn.microsoft.com/en-us/library/1ah5wsex.aspx
[creating-custom-exceptions-in-dotnet]: https://blog.gurock.com/articles/creating-custom-exceptions-in-dotnet/
[overloadable-operators]: https://msdn.microsoft.com/en-us/library/8edha89s.aspx
[custom-extension-method]: https://msdn.microsoft.com/en-us/library/bb311042.aspx
[extension-methods]: https://msdn.microsoft.com/en-us/library/bb383977.aspx
